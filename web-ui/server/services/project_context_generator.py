"""
Project Context Generator

Automatically generates and updates project-context.md
based on discovered documents and workflow outputs.
"""

import re
from pathlib import Path
from datetime import datetime
from typing import Optional, Any

from services.context_discovery import ContextDiscoveryService


class ProjectContextGenerator:
    """
    Generates and maintains the project-context.md file.
    
    This is the central document that:
    - Summarizes all project information
    - Is updated after each workflow
    - Is readable by all AI tools (Cursor, Claude Desktop, etc.)
    """
    
    TEMPLATE = '''---
type: project-context
version: 1.0
generated: "{generated}"
last_updated: "{last_updated}"
status: {status}
---

# Project Context - {project_name}

> This document is the central reference for all AI agents working on this project.
> It is automatically updated as workflows complete.

## Project Overview

**Name**: {project_name}
**Genre**: {genre}
**Status**: {status}
**Engine**: Unreal Engine 5

## Vision

{vision}

## Core Pillars

{pillars}

## Key Documents

{documents_table}

## Technical Stack

- **Engine**: {engine}
- **Platforms**: {platforms}
- **Team Size**: {team_size}

## Current Focus

{current_focus}

## Recent Activity

{recent_activity}

---
_Auto-generated by Unreal Companion_
_Last updated: {last_updated}_
'''
    
    def __init__(self, project_path: str):
        """
        Initialize the generator.
        
        Args:
            project_path: Path to the Unreal project folder
        """
        self.project_path = Path(project_path)
        if self.project_path.suffix == ".uproject":
            self.project_path = self.project_path.parent
        
        self.companion_path = self.project_path / ".unreal-companion"
        self.context_path = self.companion_path / "project-context.md"
        self.discovery = ContextDiscoveryService(str(self.project_path))
    
    def generate(self, force: bool = False) -> str:
        """
        Generate or update the project-context.md file.
        
        Args:
            force: If True, regenerate even if file exists
            
        Returns:
            Generated content
        """
        # Discover existing context
        context = self.discovery.discover()
        
        # Load existing context file if it exists
        existing_data = self._load_existing()
        
        # Build data for template
        now = datetime.now().isoformat()
        
        data = {
            'generated': existing_data.get('generated', now),
            'last_updated': now,
            'project_name': context.game_name or self.project_path.name,
            'genre': context.genre or '_Not yet defined_',
            'status': context.status or 'New Project',
            'vision': self._build_vision_section(context, existing_data),
            'pillars': self._build_pillars_section(context),
            'documents_table': self._build_documents_table(context),
            'engine': 'Unreal Engine 5',
            'platforms': ', '.join(context.platforms) if context.platforms else 'TBD',
            'team_size': existing_data.get('team_size', 'TBD'),
            'current_focus': context.current_focus or '_No active focus. Start a workflow!_',
            'recent_activity': self._build_activity_section(),
        }
        
        # Generate content
        content = self.TEMPLATE.format(**data)
        
        # Save
        self.companion_path.mkdir(parents=True, exist_ok=True)
        self.context_path.write_text(content)
        
        return content
    
    def update_from_workflow(
        self,
        workflow_id: str,
        responses: dict,
        output_path: str = None,
    ) -> str:
        """
        Update project-context.md after a workflow completes.
        
        Args:
            workflow_id: Completed workflow ID
            responses: Workflow responses
            output_path: Path to generated document
            
        Returns:
            Updated content
        """
        # Load existing
        existing_data = self._load_existing()
        
        # Update based on workflow type
        updates = {}
        
        if workflow_id == 'project-lite':
            updates['game_name'] = responses.get('game_name')
            updates['genre'] = responses.get('genre')
            updates['vision'] = responses.get('concept')
            updates['status'] = 'Initialized'
        
        elif workflow_id == 'game-brief':
            updates['game_name'] = responses.get('game_name')
            updates['vision'] = responses.get('elevator_pitch')
            updates['pillars'] = [
                responses.get('pillar_1'),
                responses.get('pillar_2'),
                responses.get('pillar_3'),
            ]
            updates['platforms'] = responses.get('platforms')
            updates['team_size'] = responses.get('team_size')
            updates['status'] = 'Brief Complete'
        
        elif workflow_id == 'gdd':
            updates['status'] = 'GDD Complete'
        
        # Merge updates into existing data
        for key, value in updates.items():
            if value:
                existing_data[key] = value
        
        # Add activity
        self._add_activity(f"Completed {workflow_id} workflow")
        
        # Regenerate
        return self.generate()
    
    def _load_existing(self) -> dict:
        """Load existing project-context.md data."""
        if not self.context_path.exists():
            return {}
        
        try:
            content = self.context_path.read_text()
            data = {}
            
            # Parse frontmatter
            if content.startswith('---'):
                parts = content.split('---', 2)
                if len(parts) >= 3:
                    import yaml
                    frontmatter = yaml.safe_load(parts[1])
                    if frontmatter:
                        data.update(frontmatter)
            
            # Parse key fields from markdown
            patterns = {
                'game_name': r'\*\*Name\*\*:\s*(.+)',
                'genre': r'\*\*Genre\*\*:\s*(.+)',
                'status': r'\*\*Status\*\*:\s*(.+)',
                'team_size': r'\*\*Team Size\*\*:\s*(.+)',
            }
            
            for key, pattern in patterns.items():
                match = re.search(pattern, content)
                if match:
                    value = match.group(1).strip()
                    if value and value != '_Not yet defined_' and value != 'TBD':
                        data[key] = value
            
            return data
        except Exception:
            return {}
    
    def _build_vision_section(self, context, existing_data: dict) -> str:
        """Build the vision section."""
        if existing_data.get('vision'):
            return existing_data['vision']
        
        # Check for game brief
        brief = self.discovery.get_document_by_type('game-brief')
        if brief:
            return f"_See [Game Brief]({brief.path}) for full vision._"
        
        return '_Not yet defined. Run the `game-brief` workflow to define your vision._'
    
    def _build_pillars_section(self, context) -> str:
        """Build the pillars section."""
        if context.pillars:
            return '\n'.join(f'- **{p}**' for p in context.pillars)
        
        return '_No pillars defined. Complete a Game Brief to define pillars._'
    
    def _build_documents_table(self, context) -> str:
        """Build the documents table."""
        docs = {
            'Game Brief': ('output/concept/game-brief.md', 'game-brief'),
            'GDD': ('output/design/gdd.md', 'gdd'),
            'Technical Architecture': ('output/technical/architecture.md', 'architecture'),
        }
        
        lines = ['| Document | Status | Path |', '|----------|--------|------|']
        
        for name, (path, doc_type) in docs.items():
            doc = self.discovery.get_document_by_type(doc_type)
            if doc:
                status = '✅ Complete'
                link = f'[{name}]({doc.path})'
            else:
                status = '❌ Not created'
                link = f'`{path}`'
            lines.append(f'| {name} | {status} | {link} |')
        
        return '\n'.join(lines)
    
    def _build_activity_section(self) -> str:
        """Build recent activity section."""
        activity_path = self.companion_path / "sessions" / "activity.log"
        
        if not activity_path.exists():
            return '_No activity yet._'
        
        try:
            lines = activity_path.read_text().strip().split('\n')
            recent = lines[-5:]  # Last 5 entries
            return '\n'.join(f'- {line}' for line in reversed(recent))
        except Exception:
            return '_No activity yet._'
    
    def _add_activity(self, message: str):
        """Add an activity log entry."""
        activity_path = self.companion_path / "sessions" / "activity.log"
        activity_path.parent.mkdir(parents=True, exist_ok=True)
        
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M')
        entry = f"{timestamp}: {message}\n"
        
        with open(activity_path, 'a') as f:
            f.write(entry)


# === API Integration ===

def update_project_context(
    project_path: str,
    workflow_id: str = None,
    responses: dict = None,
) -> str:
    """
    Convenience function to update project context.
    
    Args:
        project_path: Path to project
        workflow_id: Optional workflow that completed
        responses: Optional workflow responses
        
    Returns:
        Updated content
    """
    generator = ProjectContextGenerator(project_path)
    
    if workflow_id and responses:
        return generator.update_from_workflow(workflow_id, responses)
    else:
        return generator.generate()
