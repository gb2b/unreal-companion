"""
Studio API - Manages documents and workflows for the Studio feature.
Documents are stored in the docs/ folder of the Unreal project.
"""

from fastapi import APIRouter, HTTPException, Body
from pydantic import BaseModel
from typing import Optional, List, Dict, Any
from pathlib import Path
import os
import json
from datetime import datetime

router = APIRouter(prefix="/api/studio", tags=["studio"])

# ============ MODELS ============

class StudioProject(BaseModel):
    """Studio project configuration"""
    id: str
    name: str
    uproject_path: Optional[str] = None
    docs_path: Optional[str] = None
    
class DocumentInfo(BaseModel):
    """Document metadata"""
    path: str
    name: str
    type: str  # 'file' or 'folder'
    size: Optional[int] = None
    modified: Optional[str] = None
    status: Optional[str] = None  # 'complete', 'in_progress', 'not_started'

class CreateDocumentRequest(BaseModel):
    """Request to create a document"""
    path: str
    content: str
    
class WorkflowStateRequest(BaseModel):
    """Request to save workflow state"""
    workflow_id: str
    step: int
    responses: Dict[str, Any]


# ============ TASK MODELS ============

class HistoryEntry(BaseModel):
    """Task history entry"""
    date: str
    action: str  # 'created', 'started', 'done', 'reopened', 'moved', 'updated', 'dependency_added', 'dependency_removed', 'subtask_added'
    by: str  # 'user', 'workflow', 'editor'
    notes: Optional[str] = None
    session: Optional[str] = None
    reason: Optional[str] = None
    from_sector: Optional[str] = None
    to_sector: Optional[str] = None


class TaskCreate(BaseModel):
    """Request to create a task"""
    title: str
    description: Optional[str] = ""
    sector: str
    agent: Optional[str] = None
    priority: str = "medium"  # 'low', 'medium', 'high', 'critical'
    parent_id: Optional[str] = None
    requires: Optional[List[str]] = []
    created_by: str = "user"  # 'user', 'workflow', 'editor'


class TaskUpdate(BaseModel):
    """Request to update a task"""
    title: Optional[str] = None
    description: Optional[str] = None
    sector: Optional[str] = None
    agent: Optional[str] = None
    priority: Optional[str] = None
    status: Optional[str] = None
    requires: Optional[List[str]] = None


class TaskAction(BaseModel):
    """Request for task actions (start, complete, reopen, move)"""
    action: str  # 'start', 'complete', 'reopen', 'move'
    agent: Optional[str] = None  # For 'start' action
    to_sector: Optional[str] = None  # For 'move' action
    reason: Optional[str] = None  # For 'move' action
    by: str = "user"


class QueueModel(BaseModel):
    """Queue (sector) model"""
    id: str
    name: str
    icon: str
    color: str
    description: Optional[str] = ""
    default_agent: Optional[str] = None
    order: int
    is_default: Optional[bool] = False

# ============ HELPERS ============

def get_docs_path(uproject_path: Optional[str]) -> Optional[Path]:
    """Get the docs/ folder path from a .uproject path"""
    if not uproject_path:
        return None
    
    project_dir = Path(uproject_path).parent
    docs_path = project_dir / "docs"
    return docs_path

def ensure_docs_structure(docs_path: Path):
    """Create the default docs folder structure"""
    folders = ['concept', 'design', 'technical', 'production', 'assets']
    
    docs_path.mkdir(parents=True, exist_ok=True)
    
    for folder in folders:
        (docs_path / folder).mkdir(exist_ok=True)
    
    # Create COMPANION.md if it doesn't exist
    companion_path = docs_path / "COMPANION.md"
    if not companion_path.exists():
        companion_path.write_text(f"""# Companion Index

> This is your project's source of truth. All LLM clients (Cursor, Claude Code, etc.) should start here.

## Project Info

- **Created**: {datetime.now().strftime('%Y-%m-%d')}
- **Status**: Getting Started
- **Web UI**: http://localhost:8000

## Current Focus

Not set yet. Start a workflow to define your game!

## Documents

No documents yet. Recommended first steps:

1. Run **Quick Prototype** workflow (5 min) â†’ `concept/quick-prototype.md`
2. Create a **Game Brief** (30 min) â†’ `concept/game-brief.md`
3. Design your **Architecture** â†’ `technical/architecture.md`

## Folders

- `concept/` - Vision, briefs, prototypes
- `design/` - GDD, mechanics, narrative
- `technical/` - Architecture, specs, APIs
- `production/` - Sprints, milestones, planning
- `assets/` - Asset lists, references

## Task Board

See `docs/.companion/tasks.json` for current tasks.

---
*Generated by Unreal Companion Studio*
""")
    
    # Create .companion config folder
    config_path = docs_path / ".companion"
    config_path.mkdir(exist_ok=True)
    
    config_file = config_path / "config.json"
    if not config_file.exists():
        config_file.write_text(json.dumps({
            "created_at": datetime.now().isoformat(),
            "version": "1.0"
        }, indent=2))
    
    # Create default tasks.json with new queue-based format
    tasks_file = config_path / "tasks.json"
    if not tasks_file.exists():
        tasks_file.write_text(json.dumps({
            "queues": [
                {
                    "id": "concept",
                    "name": "Concept",
                    "icon": "Target",
                    "color": "blue",
                    "description": "Game design, mechanics, vision",
                    "default_agent": "game-designer",
                    "order": 0,
                    "is_default": True
                },
                {
                    "id": "dev",
                    "name": "Development",
                    "icon": "Code",
                    "color": "green",
                    "description": "Blueprints, systems, code",
                    "default_agent": "game-architect",
                    "order": 1,
                    "is_default": True
                },
                {
                    "id": "art",
                    "name": "Art",
                    "icon": "Palette",
                    "color": "pink",
                    "description": "Materials, textures, 3D assets",
                    "default_agent": "3d-artist",
                    "order": 2,
                    "is_default": True
                },
                {
                    "id": "levels",
                    "name": "Level Design",
                    "icon": "Map",
                    "color": "amber",
                    "description": "Levels, lighting, world building",
                    "default_agent": "level-designer",
                    "order": 3,
                    "is_default": True
                }
            ],
            "tasks": [],
            "updated_at": datetime.now().isoformat()
        }, indent=2))

# ============ ENDPOINTS ============

@router.post("/init")
async def initialize_studio(uproject_path: str = Body(..., embed=True)):
    """Initialize the Studio structure for a project"""
    docs_path = get_docs_path(uproject_path)
    
    if not docs_path:
        raise HTTPException(status_code=400, detail="Invalid uproject path")
    
    try:
        ensure_docs_structure(docs_path)
        return {
            "success": True,
            "docs_path": str(docs_path),
            "message": f"Studio initialized at {docs_path}"
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/docs")
async def list_documents(uproject_path: str):
    """List all documents in the Studio"""
    docs_path = get_docs_path(uproject_path)
    
    if not docs_path or not docs_path.exists():
        return {"documents": []}
    
    documents: List[DocumentInfo] = []
    
    def scan_folder(folder: Path, prefix: str = ""):
        for item in sorted(folder.iterdir()):
            if item.name.startswith('.'):
                continue
                
            rel_path = f"{prefix}/{item.name}" if prefix else item.name
            
            if item.is_dir():
                documents.append(DocumentInfo(
                    path=rel_path,
                    name=item.name,
                    type='folder'
                ))
                scan_folder(item, rel_path)
            else:
                stat = item.stat()
                documents.append(DocumentInfo(
                    path=rel_path,
                    name=item.name,
                    type='file',
                    size=stat.st_size,
                    modified=datetime.fromtimestamp(stat.st_mtime).isoformat()
                ))
    
    scan_folder(docs_path)
    
    return {"documents": documents}

@router.get("/docs/{path:path}")
async def read_document(path: str, uproject_path: str):
    """Read a document's content"""
    docs_path = get_docs_path(uproject_path)
    
    if not docs_path:
        raise HTTPException(status_code=400, detail="Invalid uproject path")
    
    file_path = docs_path / path
    
    if not file_path.exists():
        raise HTTPException(status_code=404, detail="Document not found")
    
    if file_path.is_dir():
        raise HTTPException(status_code=400, detail="Cannot read a folder")
    
    try:
        content = file_path.read_text()
        return {
            "path": path,
            "content": content,
            "modified": datetime.fromtimestamp(file_path.stat().st_mtime).isoformat()
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/docs")
async def create_document(request: CreateDocumentRequest, uproject_path: str):
    """Create or update a document"""
    docs_path = get_docs_path(uproject_path)
    
    if not docs_path:
        raise HTTPException(status_code=400, detail="Invalid uproject path")
    
    file_path = docs_path / request.path
    
    # Ensure parent directory exists
    file_path.parent.mkdir(parents=True, exist_ok=True)
    
    try:
        file_path.write_text(request.content)
        return {
            "success": True,
            "path": request.path,
            "message": f"Document saved at {request.path}"
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.delete("/docs/{path:path}")
async def delete_document(path: str, uproject_path: str):
    """Delete a document"""
    docs_path = get_docs_path(uproject_path)
    
    if not docs_path:
        raise HTTPException(status_code=400, detail="Invalid uproject path")
    
    file_path = docs_path / path
    
    if not file_path.exists():
        raise HTTPException(status_code=404, detail="Document not found")
    
    try:
        if file_path.is_dir():
            import shutil
            shutil.rmtree(file_path)
        else:
            file_path.unlink()
        
        return {"success": True, "message": f"Deleted {path}"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/companion")
async def get_companion_index(uproject_path: str):
    """Get the COMPANION.md index file"""
    docs_path = get_docs_path(uproject_path)
    
    if not docs_path:
        raise HTTPException(status_code=400, detail="Invalid uproject path")
    
    companion_path = docs_path / "COMPANION.md"
    
    if not companion_path.exists():
        return {"content": None, "exists": False}
    
    return {
        "content": companion_path.read_text(),
        "exists": True,
        "modified": datetime.fromtimestamp(companion_path.stat().st_mtime).isoformat()
    }

@router.post("/companion/refresh")
async def refresh_companion_index(uproject_path: str = Body(..., embed=True)):
    """Regenerate the COMPANION.md index from all documents"""
    docs_path = get_docs_path(uproject_path)
    
    if not docs_path:
        raise HTTPException(status_code=400, detail="Invalid uproject path")
    
    # Scan for documents and generate index
    sections = {
        'concept': [],
        'design': [],
        'technical': [],
        'production': [],
        'assets': []
    }
    
    for folder, docs in sections.items():
        folder_path = docs_path / folder
        if folder_path.exists():
            for item in folder_path.iterdir():
                if item.is_file() and item.suffix == '.md':
                    docs.append({
                        'name': item.stem.replace('-', ' ').title(),
                        'path': f"{folder}/{item.name}"
                    })
    
    # Generate markdown
    content = f"""# Companion Index

## Project Info
- Last Updated: {datetime.now().strftime('%Y-%m-%d %H:%M')}

## Documents

"""
    
    for section, docs in sections.items():
        if docs:
            content += f"### {section.title()}\n"
            for doc in docs:
                content += f"- [{doc['name']}]({doc['path']})\n"
            content += "\n"
    
    if not any(sections.values()):
        content += "No documents yet.\n"
    
    content += "\n## Current Focus\nNot set\n"
    
    # Save
    companion_path = docs_path / "COMPANION.md"
    companion_path.write_text(content)
    
    return {
        "success": True,
        "content": content
    }

@router.get("/workflow/state/{workflow_id}")
async def get_workflow_state(workflow_id: str, uproject_path: str):
    """Get the saved state of a workflow"""
    docs_path = get_docs_path(uproject_path)
    
    if not docs_path:
        raise HTTPException(status_code=400, detail="Invalid uproject path")
    
    state_file = docs_path / ".companion" / "workflows" / f"{workflow_id}.json"
    
    if not state_file.exists():
        return {"state": None}
    
    try:
        state = json.loads(state_file.read_text())
        return {"state": state}
    except:
        return {"state": None}

@router.post("/workflow/state")
async def save_workflow_state(request: WorkflowStateRequest, uproject_path: str):
    """Save the current state of a workflow"""
    docs_path = get_docs_path(uproject_path)
    
    if not docs_path:
        raise HTTPException(status_code=400, detail="Invalid uproject path")
    
    workflows_path = docs_path / ".companion" / "workflows"
    workflows_path.mkdir(parents=True, exist_ok=True)
    
    state_file = workflows_path / f"{request.workflow_id}.json"
    
    state = {
        "workflow_id": request.workflow_id,
        "step": request.step,
        "responses": request.responses,
        "updated_at": datetime.now().isoformat()
    }
    
    state_file.write_text(json.dumps(state, indent=2))
    
    return {"success": True}

@router.post("/workflow/complete")
async def complete_workflow(
    workflow_id: str = Body(...),
    responses: Dict[str, Any] = Body(...),
    output_path: str = Body(...),
    output_content: str = Body(...),
    uproject_path: str = Body(...)
):
    """Complete a workflow and save the generated document"""
    docs_path = get_docs_path(uproject_path)
    
    if not docs_path:
        raise HTTPException(status_code=400, detail="Invalid uproject path")
    
    # Save the document
    file_path = docs_path / output_path
    file_path.parent.mkdir(parents=True, exist_ok=True)
    file_path.write_text(output_content)
    
    # Clean up workflow state
    state_file = docs_path / ".companion" / "workflows" / f"{workflow_id}.json"
    if state_file.exists():
        state_file.unlink()
    
    # Refresh companion index
    await refresh_companion_index(str(docs_path.parent / (docs_path.parent.name + ".uproject")))
    
    return {
        "success": True,
        "document_path": output_path,
        "message": f"Workflow completed. Document saved at {output_path}"
    }

# ============ LLM-POWERED ENDPOINTS ============

class SuggestionsRequest(BaseModel):
    """Request for context-aware suggestions"""
    type: str  # 'references_by_genre', 'mechanics', 'features', etc.
    context: Dict[str, Any]  # Current workflow context
    locale: str = 'en'

class BriefAnalyzeRequest(BaseModel):
    """Request to analyze an uploaded brief"""
    content: str
    format: str = 'md'  # 'md', 'txt', 'pdf_text'
    locale: str = 'en'

# Reference games by genre (fallback if LLM not available)
GENRE_REFERENCES = {
    'action': ['DOOM', 'Titanfall 2', 'Devil May Cry 5', 'Bayonetta', 'Control'],
    'adventure': ['The Witcher 3', 'Zelda: BotW', 'Uncharted 4', 'Horizon Zero Dawn'],
    'rpg': ['Baldur\'s Gate 3', 'Divinity: Original Sin 2', 'Elden Ring', 'Persona 5'],
    'roguelike': ['Hades', 'Dead Cells', 'Spelunky 2', 'Enter the Gungeon', 'Slay the Spire'],
    'puzzle': ['Portal 2', 'The Witness', 'Baba Is You', 'Return of the Obra Dinn'],
    'platformer': ['Celeste', 'Hollow Knight', 'Ori', 'Super Meat Boy', 'Shovel Knight'],
    'simulation': ['Stardew Valley', 'Factorio', 'RimWorld', 'Cities: Skylines'],
    'other': ['Hades', 'Celeste', 'Hollow Knight', 'The Witcher 3', 'Portal 2'],
}

@router.post("/suggestions")
async def get_suggestions(request: SuggestionsRequest):
    """Get context-aware suggestions (references, mechanics, etc.)
    
    For now, uses fallback data. Can be enhanced with LLM calls.
    """
    suggestions = []
    
    if request.type == 'references_by_genre':
        genre = request.context.get('genre', 'other')
        suggestions = GENRE_REFERENCES.get(genre, GENRE_REFERENCES['other'])
    
    elif request.type == 'mechanics':
        # Could be enhanced with LLM
        genre = request.context.get('genre', 'other')
        mechanics_by_genre = {
            'roguelike': ['Procedural generation', 'Permadeath', 'Meta-progression', 'Build variety'],
            'action': ['Combo system', 'Dodge/parry', 'Weapon variety', 'Boss battles'],
            'rpg': ['Skill trees', 'Dialogue choices', 'Equipment system', 'Quest branching'],
        }
        suggestions = mechanics_by_genre.get(genre, ['Core loop', 'Progression', 'Player feedback'])
    
    elif request.type == 'feelings':
        suggestions = ['Powerful', 'Clever', 'Tense', 'Relaxed', 'Curious', 'Creative']
    
    return {
        "suggestions": suggestions,
        "source": "fallback"  # Could be "llm" when enhanced
    }

@router.post("/brief/analyze")
async def analyze_brief(request: BriefAnalyzeRequest):
    """Analyze an uploaded brief and extract key information
    
    For now, does basic text extraction. Can be enhanced with LLM.
    """
    content = request.content.strip()
    
    # Basic extraction (can be enhanced with LLM)
    extracted = {
        "gameName": None,
        "concept": None,
        "genre": None,
        "inspirations": [],
        "features": [],
    }
    
    lines = content.split('\n')
    
    for i, line in enumerate(lines):
        line_lower = line.lower().strip()
        
        # Try to extract game name from title
        if line.startswith('# ') and not extracted['gameName']:
            extracted['gameName'] = line[2:].strip()
        
        # Look for genre keywords
        if 'genre' in line_lower or 'type' in line_lower:
            for genre in ['action', 'adventure', 'rpg', 'roguelike', 'puzzle', 'platformer', 'simulation']:
                if genre in line_lower or (i + 1 < len(lines) and genre in lines[i + 1].lower()):
                    extracted['genre'] = genre
                    break
        
        # Look for inspiration/reference keywords
        if 'inspir' in line_lower or 'reference' in line_lower or 'like' in line_lower:
            # Check next few lines for game names
            for j in range(i, min(i + 3, len(lines))):
                for game in ['Hades', 'Celeste', 'Hollow Knight', 'Dark Souls', 'Zelda', 'Mario']:
                    if game.lower() in lines[j].lower() and game not in extracted['inspirations']:
                        extracted['inspirations'].append(game)
    
    # If no name found, use first significant line
    if not extracted['gameName']:
        for line in lines:
            if line.strip() and not line.startswith('#') and len(line.strip()) > 3:
                extracted['gameName'] = line.strip()[:50]
                break
    
    # Extract concept (first paragraph after title)
    concept_lines = []
    in_concept = False
    for line in lines:
        if line.startswith('# '):
            in_concept = True
            continue
        if in_concept:
            if line.strip():
                concept_lines.append(line.strip())
            if len(concept_lines) >= 3:
                break
    
    if concept_lines:
        extracted['concept'] = ' '.join(concept_lines)[:300]
    
    return {
        "extracted": extracted,
        "confidence": 0.5,  # Low confidence for basic extraction
        "source": "regex"  # Could be "llm" when enhanced
    }

@router.get("/tasks")
async def get_tasks(uproject_path: str):
    """Get tasks from the tasks.json file"""
    docs_path = get_docs_path(uproject_path)

    if not docs_path:
        return {"tasks": [], "queues": []}

    tasks_file = docs_path / ".companion" / "tasks.json"

    if not tasks_file.exists():
        return {"tasks": [], "queues": []}

    try:
        data = json.loads(tasks_file.read_text())
        # Handle legacy format (sectors -> queues)
        if "sectors" in data and "queues" not in data:
            data["queues"] = data.pop("sectors")
        return data
    except:
        return {"tasks": [], "queues": []}

@router.post("/tasks/sync")
async def sync_tasks(
    tasks: List[Dict[str, Any]] = Body(...),
    queues: List[Dict[str, Any]] = Body(default=None),
    sectors: List[Dict[str, Any]] = Body(default=None),  # Legacy support
    uproject_path: str = Body(...)
):
    """Sync tasks to the tasks.json file"""
    docs_path = get_docs_path(uproject_path)

    if not docs_path:
        raise HTTPException(status_code=400, detail="Invalid uproject path")

    config_path = docs_path / ".companion"
    config_path.mkdir(parents=True, exist_ok=True)

    tasks_file = config_path / "tasks.json"

    # Use queues if provided, otherwise fall back to sectors for legacy support
    final_queues = queues if queues is not None else (sectors if sectors is not None else [])

    data = {
        "queues": final_queues,
        "tasks": tasks,
        "updated_at": datetime.now().isoformat()
    }

    tasks_file.write_text(json.dumps(data, indent=2))

    return {"success": True}


# ============ TASK CRUD HELPERS ============

def load_tasks_data(docs_path: Path) -> Dict[str, Any]:
    """Load tasks data from file"""
    tasks_file = docs_path / ".companion" / "tasks.json"
    if not tasks_file.exists():
        return {"queues": [], "tasks": [], "updated_at": datetime.now().isoformat()}
    try:
        data = json.loads(tasks_file.read_text())
        # Handle legacy format
        if "sectors" in data and "queues" not in data:
            data["queues"] = data.pop("sectors")
        return data
    except:
        return {"queues": [], "tasks": [], "updated_at": datetime.now().isoformat()}


def save_tasks_data(docs_path: Path, data: Dict[str, Any]):
    """Save tasks data to file"""
    config_path = docs_path / ".companion"
    config_path.mkdir(parents=True, exist_ok=True)
    tasks_file = config_path / "tasks.json"
    data["updated_at"] = datetime.now().isoformat()
    tasks_file.write_text(json.dumps(data, indent=2))


def compute_task_status(task: Dict[str, Any], all_tasks: List[Dict[str, Any]]) -> str:
    """Compute task status based on dependencies"""
    current_status = task.get("status", "ready")

    # Keep active statuses
    if current_status in ("in_progress", "done"):
        return current_status

    requires = task.get("requires", [])
    if not requires:
        return "ready"

    # Check all dependencies
    for dep_id in requires:
        dep = next((t for t in all_tasks if t.get("id") == dep_id), None)
        if not dep or dep.get("status") != "done":
            return "locked"

    return "ready"


def recompute_all_statuses(tasks: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """Recompute locked/ready statuses for all tasks"""
    for task in tasks:
        if task.get("status") not in ("in_progress", "done"):
            task["status"] = compute_task_status(task, tasks)
    return tasks


def generate_task_id() -> str:
    """Generate a unique task ID"""
    import uuid
    return str(uuid.uuid4())[:8]


def create_history_entry(action: str, by: str, **kwargs) -> Dict[str, Any]:
    """Create a history entry"""
    entry = {
        "date": datetime.now().isoformat(),
        "action": action,
        "by": by
    }
    entry.update({k: v for k, v in kwargs.items() if v is not None})
    return entry


# ============ TASK CRUD ENDPOINTS ============

@router.post("/tasks/create")
async def create_task(task: TaskCreate, uproject_path: str):
    """Create a new task"""
    docs_path = get_docs_path(uproject_path)
    if not docs_path:
        raise HTTPException(status_code=400, detail="Invalid uproject path")

    data = load_tasks_data(docs_path)

    # Find default agent for the queue if not specified
    queue = next((q for q in data.get("queues", []) if q.get("id") == task.sector), None)
    agent = task.agent or (queue.get("default_agent") if queue else None) or ""

    # Compute initial status
    initial_status = "ready" if not task.requires else "locked"

    now = datetime.now().isoformat()
    new_task = {
        "id": generate_task_id(),
        "title": task.title,
        "description": task.description or "",
        "sector": task.sector,
        "agent": agent,
        "priority": task.priority,
        "status": initial_status,
        "parent_id": task.parent_id,
        "requires": task.requires or [],
        "history": [create_history_entry("created", task.created_by)],
        "iteration": 1,
        "created_at": now,
        "updated_at": now,
        "created_by": task.created_by
    }

    data["tasks"].append(new_task)
    data["tasks"] = recompute_all_statuses(data["tasks"])

    # If this is a subtask, mark parent as is_parent
    if task.parent_id:
        for t in data["tasks"]:
            if t.get("id") == task.parent_id:
                t["is_parent"] = True
                t["history"].append(create_history_entry("subtask_added", task.created_by))
                break

    save_tasks_data(docs_path, data)

    return {"success": True, "task": new_task}


@router.put("/tasks/{task_id}")
async def update_task(task_id: str, updates: TaskUpdate, uproject_path: str):
    """Update a task"""
    docs_path = get_docs_path(uproject_path)
    if not docs_path:
        raise HTTPException(status_code=400, detail="Invalid uproject path")

    data = load_tasks_data(docs_path)

    task_index = next((i for i, t in enumerate(data["tasks"]) if t.get("id") == task_id), None)
    if task_index is None:
        raise HTTPException(status_code=404, detail="Task not found")

    task = data["tasks"][task_index]

    # Apply updates
    update_dict = updates.dict(exclude_none=True)
    for key, value in update_dict.items():
        task[key] = value

    task["updated_at"] = datetime.now().isoformat()
    task["history"].append(create_history_entry("updated", "user"))

    # Recompute statuses if dependencies changed
    if "requires" in update_dict:
        data["tasks"] = recompute_all_statuses(data["tasks"])

    save_tasks_data(docs_path, data)

    return {"success": True, "task": task}


@router.delete("/tasks/{task_id}")
async def delete_task(task_id: str, uproject_path: str):
    """Delete a task"""
    docs_path = get_docs_path(uproject_path)
    if not docs_path:
        raise HTTPException(status_code=400, detail="Invalid uproject path")

    data = load_tasks_data(docs_path)

    # Remove task
    data["tasks"] = [t for t in data["tasks"] if t.get("id") != task_id]

    # Remove from other tasks' dependencies
    for task in data["tasks"]:
        if task_id in task.get("requires", []):
            task["requires"] = [r for r in task["requires"] if r != task_id]

    data["tasks"] = recompute_all_statuses(data["tasks"])
    save_tasks_data(docs_path, data)

    return {"success": True}


@router.post("/tasks/{task_id}/action")
async def task_action(task_id: str, action: TaskAction, uproject_path: str):
    """Perform an action on a task (start, complete, reopen, move)"""
    docs_path = get_docs_path(uproject_path)
    if not docs_path:
        raise HTTPException(status_code=400, detail="Invalid uproject path")

    data = load_tasks_data(docs_path)

    task_index = next((i for i, t in enumerate(data["tasks"]) if t.get("id") == task_id), None)
    if task_index is None:
        raise HTTPException(status_code=404, detail="Task not found")

    task = data["tasks"][task_index]
    now = datetime.now().isoformat()

    if action.action == "start":
        # Check if task can be started
        status = compute_task_status(task, data["tasks"])
        if status != "ready":
            raise HTTPException(status_code=400, detail=f"Task cannot be started - status is {status}")

        task["status"] = "in_progress"
        task["started_at"] = now
        task["updated_at"] = now
        if action.agent:
            task["agent"] = action.agent
        task["history"].append(create_history_entry("started", action.by))

    elif action.action == "complete":
        task["status"] = "done"
        task["completed_at"] = now
        task["updated_at"] = now
        task["history"].append(create_history_entry("done", action.by))
        # Recompute - dependents might become ready
        data["tasks"] = recompute_all_statuses(data["tasks"])

    elif action.action == "reopen":
        if task.get("status") != "done":
            raise HTTPException(status_code=400, detail="Can only reopen completed tasks")
        task["status"] = "ready"
        task["started_at"] = None
        task["completed_at"] = None
        task["updated_at"] = now
        task["iteration"] = task.get("iteration", 1) + 1
        task["history"].append(create_history_entry("reopened", action.by))
        # Recompute - dependents might become locked
        data["tasks"] = recompute_all_statuses(data["tasks"])

    elif action.action == "move":
        if not action.to_sector:
            raise HTTPException(status_code=400, detail="to_sector is required for move action")
        from_sector = task.get("sector")
        task["sector"] = action.to_sector
        task["updated_at"] = now
        # Update agent to queue default if available
        queue = next((q for q in data.get("queues", []) if q.get("id") == action.to_sector), None)
        if queue and queue.get("default_agent"):
            task["agent"] = queue["default_agent"]
        task["history"].append(create_history_entry(
            "moved", action.by,
            from_sector=from_sector, to_sector=action.to_sector, reason=action.reason
        ))

    else:
        raise HTTPException(status_code=400, detail=f"Unknown action: {action.action}")

    save_tasks_data(docs_path, data)

    return {"success": True, "task": task}


@router.post("/tasks/{task_id}/dependency")
async def add_dependency(task_id: str, depends_on_id: str = Body(..., embed=True), uproject_path: str = ""):
    """Add a dependency to a task"""
    docs_path = get_docs_path(uproject_path)
    if not docs_path:
        raise HTTPException(status_code=400, detail="Invalid uproject path")

    data = load_tasks_data(docs_path)

    task = next((t for t in data["tasks"] if t.get("id") == task_id), None)
    depends_on = next((t for t in data["tasks"] if t.get("id") == depends_on_id), None)

    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    if not depends_on:
        raise HTTPException(status_code=404, detail="Dependency task not found")

    if depends_on_id in task.get("requires", []):
        return {"success": True, "message": "Dependency already exists"}

    # Check for circular dependency (simple check)
    def would_create_cycle(target_id: str, visited: set) -> bool:
        if target_id in visited:
            return True
        visited.add(target_id)
        target = next((t for t in data["tasks"] if t.get("id") == target_id), None)
        if not target:
            return False
        return any(would_create_cycle(dep_id, visited.copy()) for dep_id in target.get("requires", []))

    if would_create_cycle(depends_on_id, {task_id}):
        raise HTTPException(status_code=400, detail="Would create circular dependency")

    task.setdefault("requires", []).append(depends_on_id)
    task["updated_at"] = datetime.now().isoformat()
    task["history"].append(create_history_entry(
        "dependency_added", "user",
        notes=f"Added dependency on {depends_on.get('title', depends_on_id)}"
    ))

    data["tasks"] = recompute_all_statuses(data["tasks"])
    save_tasks_data(docs_path, data)

    return {"success": True, "task": task}


@router.delete("/tasks/{task_id}/dependency/{depends_on_id}")
async def remove_dependency(task_id: str, depends_on_id: str, uproject_path: str):
    """Remove a dependency from a task"""
    docs_path = get_docs_path(uproject_path)
    if not docs_path:
        raise HTTPException(status_code=400, detail="Invalid uproject path")

    data = load_tasks_data(docs_path)

    task = next((t for t in data["tasks"] if t.get("id") == task_id), None)
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")

    if depends_on_id not in task.get("requires", []):
        return {"success": True, "message": "Dependency does not exist"}

    depends_on = next((t for t in data["tasks"] if t.get("id") == depends_on_id), None)

    task["requires"] = [r for r in task.get("requires", []) if r != depends_on_id]
    task["updated_at"] = datetime.now().isoformat()
    task["history"].append(create_history_entry(
        "dependency_removed", "user",
        notes=f"Removed dependency on {depends_on.get('title', depends_on_id) if depends_on else depends_on_id}"
    ))

    data["tasks"] = recompute_all_statuses(data["tasks"])
    save_tasks_data(docs_path, data)

    return {"success": True, "task": task}


# ============ DYNAMIC WORKFLOW GENERATION ============

class WorkflowGenerateRequest(BaseModel):
    """Request to generate dynamic workflow content"""
    workflow_id: str
    step_index: int
    step_id: str
    previous_responses: Dict[str, Any] = {}
    locale: str = 'en'
    agent: str = 'game-designer'

class DocumentGenerateRequest(BaseModel):
    """Request to generate a document from workflow responses"""
    workflow_id: str
    responses: Dict[str, Any]
    template: str
    output_path: str
    locale: str = 'en'

class PartyReviewRequest(BaseModel):
    """Request for multi-agent document review"""
    document_content: str
    document_type: str  # 'brief', 'gdd', 'architecture'
    agents: List[str] = ['game-architect', 'game-dev', 'game-designer']
    locale: str = 'en'

# Agent personalities for dynamic content
AGENT_PERSONALITIES = {
    'game-designer': {
        'name': 'Game Designer',
        'tone': 'creative and enthusiastic',
        'focus': 'player experience, fun, engagement',
        'emoji': 'ðŸŽ®'
    },
    'game-architect': {
        'name': 'Game Architect', 
        'tone': 'analytical and structured',
        'focus': 'systems, scalability, technical feasibility',
        'emoji': 'ðŸ—ï¸'
    },
    'game-dev': {
        'name': 'Game Developer',
        'tone': 'practical and solution-oriented',
        'focus': 'implementation, performance, code quality',
        'emoji': 'ðŸ’»'
    },
    'game-qa': {
        'name': 'QA Specialist',
        'tone': 'thorough and detail-oriented',
        'focus': 'testing, edge cases, user experience issues',
        'emoji': 'ðŸ”'
    }
}

@router.post("/workflow/generate")
async def generate_workflow_content(request: WorkflowGenerateRequest):
    """Generate dynamic workflow content using LLM
    
    This endpoint can be enhanced with actual LLM calls.
    For now, returns localized fallback content.
    """
    agent = AGENT_PERSONALITIES.get(request.agent, AGENT_PERSONALITIES['game-designer'])
    
    # Localized messages (fallback)
    messages = {
        'en': {
            'welcome': f"Hi! I'm your {agent['name']}. Let's work on this together!",
            'continue': "Great progress! Let's continue.",
            'almost_done': "We're almost there! Just a few more questions.",
            'genre_prompt': "What genre best describes your game?",
            'concept_prompt': "Tell me about your game concept.",
        },
        'fr': {
            'welcome': f"Salut ! Je suis ton {agent['name']}. Travaillons ensemble !",
            'continue': "Super avancement ! Continuons.",
            'almost_done': "On y est presque ! Encore quelques questions.",
            'genre_prompt': "Quel genre dÃ©crit le mieux ton jeu ?",
            'concept_prompt': "Parle-moi de ton concept de jeu.",
        },
        'es': {
            'welcome': f"Â¡Hola! Soy tu {agent['name']}. Â¡Trabajemos juntos!",
            'continue': "Â¡Gran progreso! Continuemos.",
            'almost_done': "Â¡Ya casi terminamos! Solo algunas preguntas mÃ¡s.",
            'genre_prompt': "Â¿QuÃ© gÃ©nero describe mejor tu juego?",
            'concept_prompt': "CuÃ©ntame sobre el concepto de tu juego.",
        }
    }
    
    locale_messages = messages.get(request.locale, messages['en'])
    
    # Generate contextual message based on step and previous responses
    step_messages = []
    
    if request.step_index == 0:
        step_messages.append(locale_messages['welcome'])
    elif request.step_index >= 3:
        step_messages.append(locale_messages['almost_done'])
    else:
        step_messages.append(locale_messages['continue'])
    
    # Add context-aware message based on previous responses
    if 'genre' in request.previous_responses:
        genre = request.previous_responses['genre']
        if request.locale == 'fr':
            step_messages.append(f"IntÃ©ressant choix : {genre} ! Explorons Ã§a.")
        elif request.locale == 'es':
            step_messages.append(f"Â¡Interesante elecciÃ³n: {genre}! Exploremos esto.")
        else:
            step_messages.append(f"Interesting choice: {genre}! Let's explore that.")
    
    return {
        "agentMessage": ' '.join(step_messages),
        "agentEmoji": agent['emoji'],
        "suggestions": [],
        "source": "fallback"  # Would be "llm" with actual LLM integration
    }

@router.post("/workflow/adapt")
async def adapt_workflow_questions(request: WorkflowGenerateRequest):
    """Adapt workflow questions based on previous responses
    
    Returns suggested modifications to questions based on context.
    """
    adaptations = {}
    
    # Genre-based adaptations
    genre = request.previous_responses.get('genre', '')
    
    if genre == 'roguelike':
        adaptations['mechanics'] = {
            'suggestions': ['Procedural generation', 'Permadeath', 'Meta-progression', 'Run variety'],
            'placeholder': 'e.g., procedural levels, permadeath with unlocks...'
        }
    elif genre == 'rpg':
        adaptations['mechanics'] = {
            'suggestions': ['Skill trees', 'Dialogue choices', 'Equipment system', 'Quest branching'],
            'placeholder': 'e.g., branching dialogue, character builds...'
        }
    elif genre == 'action':
        adaptations['mechanics'] = {
            'suggestions': ['Combo system', 'Dodge/parry', 'Weapon variety', 'Boss battles'],
            'placeholder': 'e.g., fast combat, weapon switching...'
        }
    
    # Platform-based adaptations
    platforms = request.previous_responses.get('platform', [])
    if 'mobile' in platforms:
        adaptations['controls'] = {
            'note': 'Consider touch-friendly controls for mobile',
            'suggestions': ['Simple tap controls', 'Auto-aim assist', 'Short session design']
        }
    
    return {
        "adaptations": adaptations,
        "source": "rules"  # Could be "llm" with actual LLM integration
    }

@router.post("/documents/generate")
async def generate_document(request: DocumentGenerateRequest):
    """Generate a document from workflow responses
    
    Replaces template placeholders with actual responses.
    Can be enhanced with LLM for better formatting.
    """
    content = request.template
    
    # Replace all placeholders
    for key, value in request.responses.items():
        placeholder = "{{" + key + "}}"
        
        if isinstance(value, list):
            formatted_value = '\n'.join(f"- {item}" for item in value)
        else:
            formatted_value = str(value) if value else ''
        
        content = content.replace(placeholder, formatted_value)
    
    # Add generation metadata
    content = content.replace("{{date}}", datetime.now().strftime('%Y-%m-%d'))
    
    # Clean up any remaining empty placeholders
    import re
    content = re.sub(r'\{\{[^}]+\}\}', '', content)
    
    return {
        "content": content,
        "path": request.output_path,
        "source": "template"  # Could be "llm" with actual LLM enhancement
    }

@router.post("/party/review")
async def party_review(request: PartyReviewRequest):
    """Multi-agent document review (Party Mode)
    
    Each agent reviews the document from their perspective.
    """
    reviews = []
    
    # Localized review templates
    review_templates = {
        'game-architect': {
            'en': [
                "From a systems perspective, I see {strength}.",
                "Consider the technical implications of {concern}.",
                "The architecture could benefit from {suggestion}."
            ],
            'fr': [
                "D'un point de vue systÃ¨mes, je vois {strength}.",
                "ConsidÃ¨re les implications techniques de {concern}.",
                "L'architecture pourrait bÃ©nÃ©ficier de {suggestion}."
            ]
        },
        'game-dev': {
            'en': [
                "Implementation-wise, {strength} is solid.",
                "We should prototype {concern} early.",
                "I'd suggest {suggestion} for better performance."
            ],
            'fr': [
                "CÃ´tÃ© implÃ©mentation, {strength} est solide.",
                "On devrait prototyper {concern} rapidement.",
                "Je suggÃ¨re {suggestion} pour de meilleures performances."
            ]
        },
        'game-designer': {
            'en': [
                "The player experience around {strength} feels strong.",
                "I'm curious about how {concern} will feel in-game.",
                "What if we added {suggestion} to enhance engagement?"
            ],
            'fr': [
                "L'expÃ©rience joueur autour de {strength} semble forte.",
                "Je me demande comment {concern} se ressentira en jeu.",
                "Et si on ajoutait {suggestion} pour amÃ©liorer l'engagement ?"
            ]
        }
    }
    
    # Generate reviews for each agent
    for agent_id in request.agents:
        agent = AGENT_PERSONALITIES.get(agent_id, AGENT_PERSONALITIES['game-designer'])
        templates = review_templates.get(agent_id, review_templates['game-designer'])
        locale_templates = templates.get(request.locale, templates['en'])
        
        # Simulate review (would be LLM-generated in production)
        review_points = []
        
        # Analyze document for key terms
        doc_lower = request.document_content.lower()
        
        if 'roguelike' in doc_lower or 'procedural' in doc_lower:
            review_points.append({
                'type': 'strength',
                'text': locale_templates[0].format(strength='procedural generation approach')
            })
        
        if 'multiplayer' in doc_lower or 'online' in doc_lower:
            review_points.append({
                'type': 'concern', 
                'text': locale_templates[1].format(concern='network synchronization')
            })
        
        if len(request.document_content) > 1000:
            review_points.append({
                'type': 'suggestion',
                'text': locale_templates[2].format(suggestion='breaking this into smaller milestones')
            })
        
        # Default review if no specific points
        if not review_points:
            if request.locale == 'fr':
                review_points.append({
                    'type': 'general',
                    'text': f"Le document est bien structurÃ©. Continuons Ã  itÃ©rer !"
                })
            else:
                review_points.append({
                    'type': 'general',
                    'text': f"The document is well structured. Let's keep iterating!"
                })
        
        reviews.append({
            'agent': agent_id,
            'agentName': agent['name'],
            'emoji': agent['emoji'],
            'tone': agent['tone'],
            'points': review_points
        })
    
    return {
        "reviews": reviews,
        "source": "rules"  # Would be "llm" in production
    }
