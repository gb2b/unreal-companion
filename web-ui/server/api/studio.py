"""
Studio API - Manages documents and workflows for the Studio feature.
Documents are stored in the docs/ folder of the Unreal project.
"""

from fastapi import APIRouter, HTTPException, Body
from pydantic import BaseModel
from typing import Optional, List, Dict, Any
from pathlib import Path
import os
import json
from datetime import datetime

router = APIRouter(prefix="/api/studio", tags=["studio"])

# ============ MODELS ============

class StudioProject(BaseModel):
    """Studio project configuration"""
    id: str
    name: str
    uproject_path: Optional[str] = None
    docs_path: Optional[str] = None
    
class DocumentInfo(BaseModel):
    """Document metadata"""
    path: str
    name: str
    type: str  # 'file' or 'folder'
    size: Optional[int] = None
    modified: Optional[str] = None
    status: Optional[str] = None  # 'complete', 'in_progress', 'not_started'

class CreateDocumentRequest(BaseModel):
    """Request to create a document"""
    path: str
    content: str
    
class WorkflowStateRequest(BaseModel):
    """Request to save workflow state"""
    workflow_id: str
    step: int
    responses: Dict[str, Any]

# ============ HELPERS ============

def get_docs_path(uproject_path: Optional[str]) -> Optional[Path]:
    """Get the docs/ folder path from a .uproject path"""
    if not uproject_path:
        return None
    
    project_dir = Path(uproject_path).parent
    docs_path = project_dir / "docs"
    return docs_path

def ensure_docs_structure(docs_path: Path):
    """Create the default docs folder structure"""
    folders = ['concept', 'design', 'technical', 'production', 'assets']
    
    docs_path.mkdir(parents=True, exist_ok=True)
    
    for folder in folders:
        (docs_path / folder).mkdir(exist_ok=True)
    
    # Create COMPANION.md if it doesn't exist
    companion_path = docs_path / "COMPANION.md"
    if not companion_path.exists():
        companion_path.write_text(f"""# Companion Index

> This is your project's source of truth. All LLM clients (Cursor, Claude Code, etc.) should start here.

## Project Info

- **Created**: {datetime.now().strftime('%Y-%m-%d')}
- **Status**: Getting Started
- **Web UI**: http://localhost:8000

## Current Focus

Not set yet. Start a workflow to define your game!

## Documents

No documents yet. Recommended first steps:

1. Run **Quick Prototype** workflow (5 min) â†’ `concept/quick-prototype.md`
2. Create a **Game Brief** (30 min) â†’ `concept/game-brief.md`
3. Design your **Architecture** â†’ `technical/architecture.md`

## Folders

- `concept/` - Vision, briefs, prototypes
- `design/` - GDD, mechanics, narrative
- `technical/` - Architecture, specs, APIs
- `production/` - Sprints, milestones, planning
- `assets/` - Asset lists, references

## Task Board

See `docs/.companion/tasks.json` for current tasks.

---
*Generated by Unreal Companion Studio*
""")
    
    # Create .companion config folder
    config_path = docs_path / ".companion"
    config_path.mkdir(exist_ok=True)
    
    config_file = config_path / "config.json"
    if not config_file.exists():
        config_file.write_text(json.dumps({
            "created_at": datetime.now().isoformat(),
            "version": "1.0"
        }, indent=2))
    
    # Create default tasks.json
    tasks_file = config_path / "tasks.json"
    if not tasks_file.exists():
        tasks_file.write_text(json.dumps({
            "sectors": [
                {"id": "dev", "name": "Development", "icon": "Code", "color": "blue"},
                {"id": "design", "name": "Design", "icon": "Palette", "color": "purple"},
                {"id": "art", "name": "Art & Assets", "icon": "Image", "color": "pink"},
                {"id": "audio", "name": "Audio", "icon": "Music", "color": "amber"}
            ],
            "tasks": [],
            "updated_at": datetime.now().isoformat()
        }, indent=2))

# ============ ENDPOINTS ============

@router.post("/init")
async def initialize_studio(uproject_path: str = Body(..., embed=True)):
    """Initialize the Studio structure for a project"""
    docs_path = get_docs_path(uproject_path)
    
    if not docs_path:
        raise HTTPException(status_code=400, detail="Invalid uproject path")
    
    try:
        ensure_docs_structure(docs_path)
        return {
            "success": True,
            "docs_path": str(docs_path),
            "message": f"Studio initialized at {docs_path}"
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/docs")
async def list_documents(uproject_path: str):
    """List all documents in the Studio"""
    docs_path = get_docs_path(uproject_path)
    
    if not docs_path or not docs_path.exists():
        return {"documents": []}
    
    documents: List[DocumentInfo] = []
    
    def scan_folder(folder: Path, prefix: str = ""):
        for item in sorted(folder.iterdir()):
            if item.name.startswith('.'):
                continue
                
            rel_path = f"{prefix}/{item.name}" if prefix else item.name
            
            if item.is_dir():
                documents.append(DocumentInfo(
                    path=rel_path,
                    name=item.name,
                    type='folder'
                ))
                scan_folder(item, rel_path)
            else:
                stat = item.stat()
                documents.append(DocumentInfo(
                    path=rel_path,
                    name=item.name,
                    type='file',
                    size=stat.st_size,
                    modified=datetime.fromtimestamp(stat.st_mtime).isoformat()
                ))
    
    scan_folder(docs_path)
    
    return {"documents": documents}

@router.get("/docs/{path:path}")
async def read_document(path: str, uproject_path: str):
    """Read a document's content"""
    docs_path = get_docs_path(uproject_path)
    
    if not docs_path:
        raise HTTPException(status_code=400, detail="Invalid uproject path")
    
    file_path = docs_path / path
    
    if not file_path.exists():
        raise HTTPException(status_code=404, detail="Document not found")
    
    if file_path.is_dir():
        raise HTTPException(status_code=400, detail="Cannot read a folder")
    
    try:
        content = file_path.read_text()
        return {
            "path": path,
            "content": content,
            "modified": datetime.fromtimestamp(file_path.stat().st_mtime).isoformat()
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/docs")
async def create_document(request: CreateDocumentRequest, uproject_path: str):
    """Create or update a document"""
    docs_path = get_docs_path(uproject_path)
    
    if not docs_path:
        raise HTTPException(status_code=400, detail="Invalid uproject path")
    
    file_path = docs_path / request.path
    
    # Ensure parent directory exists
    file_path.parent.mkdir(parents=True, exist_ok=True)
    
    try:
        file_path.write_text(request.content)
        return {
            "success": True,
            "path": request.path,
            "message": f"Document saved at {request.path}"
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.delete("/docs/{path:path}")
async def delete_document(path: str, uproject_path: str):
    """Delete a document"""
    docs_path = get_docs_path(uproject_path)
    
    if not docs_path:
        raise HTTPException(status_code=400, detail="Invalid uproject path")
    
    file_path = docs_path / path
    
    if not file_path.exists():
        raise HTTPException(status_code=404, detail="Document not found")
    
    try:
        if file_path.is_dir():
            import shutil
            shutil.rmtree(file_path)
        else:
            file_path.unlink()
        
        return {"success": True, "message": f"Deleted {path}"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/companion")
async def get_companion_index(uproject_path: str):
    """Get the COMPANION.md index file"""
    docs_path = get_docs_path(uproject_path)
    
    if not docs_path:
        raise HTTPException(status_code=400, detail="Invalid uproject path")
    
    companion_path = docs_path / "COMPANION.md"
    
    if not companion_path.exists():
        return {"content": None, "exists": False}
    
    return {
        "content": companion_path.read_text(),
        "exists": True,
        "modified": datetime.fromtimestamp(companion_path.stat().st_mtime).isoformat()
    }

@router.post("/companion/refresh")
async def refresh_companion_index(uproject_path: str = Body(..., embed=True)):
    """Regenerate the COMPANION.md index from all documents"""
    docs_path = get_docs_path(uproject_path)
    
    if not docs_path:
        raise HTTPException(status_code=400, detail="Invalid uproject path")
    
    # Scan for documents and generate index
    sections = {
        'concept': [],
        'design': [],
        'technical': [],
        'production': [],
        'assets': []
    }
    
    for folder, docs in sections.items():
        folder_path = docs_path / folder
        if folder_path.exists():
            for item in folder_path.iterdir():
                if item.is_file() and item.suffix == '.md':
                    docs.append({
                        'name': item.stem.replace('-', ' ').title(),
                        'path': f"{folder}/{item.name}"
                    })
    
    # Generate markdown
    content = f"""# Companion Index

## Project Info
- Last Updated: {datetime.now().strftime('%Y-%m-%d %H:%M')}

## Documents

"""
    
    for section, docs in sections.items():
        if docs:
            content += f"### {section.title()}\n"
            for doc in docs:
                content += f"- [{doc['name']}]({doc['path']})\n"
            content += "\n"
    
    if not any(sections.values()):
        content += "No documents yet.\n"
    
    content += "\n## Current Focus\nNot set\n"
    
    # Save
    companion_path = docs_path / "COMPANION.md"
    companion_path.write_text(content)
    
    return {
        "success": True,
        "content": content
    }

@router.get("/workflow/state/{workflow_id}")
async def get_workflow_state(workflow_id: str, uproject_path: str):
    """Get the saved state of a workflow"""
    docs_path = get_docs_path(uproject_path)
    
    if not docs_path:
        raise HTTPException(status_code=400, detail="Invalid uproject path")
    
    state_file = docs_path / ".companion" / "workflows" / f"{workflow_id}.json"
    
    if not state_file.exists():
        return {"state": None}
    
    try:
        state = json.loads(state_file.read_text())
        return {"state": state}
    except:
        return {"state": None}

@router.post("/workflow/state")
async def save_workflow_state(request: WorkflowStateRequest, uproject_path: str):
    """Save the current state of a workflow"""
    docs_path = get_docs_path(uproject_path)
    
    if not docs_path:
        raise HTTPException(status_code=400, detail="Invalid uproject path")
    
    workflows_path = docs_path / ".companion" / "workflows"
    workflows_path.mkdir(parents=True, exist_ok=True)
    
    state_file = workflows_path / f"{request.workflow_id}.json"
    
    state = {
        "workflow_id": request.workflow_id,
        "step": request.step,
        "responses": request.responses,
        "updated_at": datetime.now().isoformat()
    }
    
    state_file.write_text(json.dumps(state, indent=2))
    
    return {"success": True}

@router.post("/workflow/complete")
async def complete_workflow(
    workflow_id: str = Body(...),
    responses: Dict[str, Any] = Body(...),
    output_path: str = Body(...),
    output_content: str = Body(...),
    uproject_path: str = Body(...)
):
    """Complete a workflow and save the generated document"""
    docs_path = get_docs_path(uproject_path)
    
    if not docs_path:
        raise HTTPException(status_code=400, detail="Invalid uproject path")
    
    # Save the document
    file_path = docs_path / output_path
    file_path.parent.mkdir(parents=True, exist_ok=True)
    file_path.write_text(output_content)
    
    # Clean up workflow state
    state_file = docs_path / ".companion" / "workflows" / f"{workflow_id}.json"
    if state_file.exists():
        state_file.unlink()
    
    # Refresh companion index
    await refresh_companion_index(str(docs_path.parent / (docs_path.parent.name + ".uproject")))
    
    return {
        "success": True,
        "document_path": output_path,
        "message": f"Workflow completed. Document saved at {output_path}"
    }

# ============ LLM-POWERED ENDPOINTS ============

class SuggestionsRequest(BaseModel):
    """Request for context-aware suggestions"""
    type: str  # 'references_by_genre', 'mechanics', 'features', etc.
    context: Dict[str, Any]  # Current workflow context
    locale: str = 'en'

class BriefAnalyzeRequest(BaseModel):
    """Request to analyze an uploaded brief"""
    content: str
    format: str = 'md'  # 'md', 'txt', 'pdf_text'
    locale: str = 'en'

# Reference games by genre (fallback if LLM not available)
GENRE_REFERENCES = {
    'action': ['DOOM', 'Titanfall 2', 'Devil May Cry 5', 'Bayonetta', 'Control'],
    'adventure': ['The Witcher 3', 'Zelda: BotW', 'Uncharted 4', 'Horizon Zero Dawn'],
    'rpg': ['Baldur\'s Gate 3', 'Divinity: Original Sin 2', 'Elden Ring', 'Persona 5'],
    'roguelike': ['Hades', 'Dead Cells', 'Spelunky 2', 'Enter the Gungeon', 'Slay the Spire'],
    'puzzle': ['Portal 2', 'The Witness', 'Baba Is You', 'Return of the Obra Dinn'],
    'platformer': ['Celeste', 'Hollow Knight', 'Ori', 'Super Meat Boy', 'Shovel Knight'],
    'simulation': ['Stardew Valley', 'Factorio', 'RimWorld', 'Cities: Skylines'],
    'other': ['Hades', 'Celeste', 'Hollow Knight', 'The Witcher 3', 'Portal 2'],
}

@router.post("/suggestions")
async def get_suggestions(request: SuggestionsRequest):
    """Get context-aware suggestions (references, mechanics, etc.)
    
    For now, uses fallback data. Can be enhanced with LLM calls.
    """
    suggestions = []
    
    if request.type == 'references_by_genre':
        genre = request.context.get('genre', 'other')
        suggestions = GENRE_REFERENCES.get(genre, GENRE_REFERENCES['other'])
    
    elif request.type == 'mechanics':
        # Could be enhanced with LLM
        genre = request.context.get('genre', 'other')
        mechanics_by_genre = {
            'roguelike': ['Procedural generation', 'Permadeath', 'Meta-progression', 'Build variety'],
            'action': ['Combo system', 'Dodge/parry', 'Weapon variety', 'Boss battles'],
            'rpg': ['Skill trees', 'Dialogue choices', 'Equipment system', 'Quest branching'],
        }
        suggestions = mechanics_by_genre.get(genre, ['Core loop', 'Progression', 'Player feedback'])
    
    elif request.type == 'feelings':
        suggestions = ['Powerful', 'Clever', 'Tense', 'Relaxed', 'Curious', 'Creative']
    
    return {
        "suggestions": suggestions,
        "source": "fallback"  # Could be "llm" when enhanced
    }

@router.post("/brief/analyze")
async def analyze_brief(request: BriefAnalyzeRequest):
    """Analyze an uploaded brief and extract key information
    
    For now, does basic text extraction. Can be enhanced with LLM.
    """
    content = request.content.strip()
    
    # Basic extraction (can be enhanced with LLM)
    extracted = {
        "gameName": None,
        "concept": None,
        "genre": None,
        "inspirations": [],
        "features": [],
    }
    
    lines = content.split('\n')
    
    for i, line in enumerate(lines):
        line_lower = line.lower().strip()
        
        # Try to extract game name from title
        if line.startswith('# ') and not extracted['gameName']:
            extracted['gameName'] = line[2:].strip()
        
        # Look for genre keywords
        if 'genre' in line_lower or 'type' in line_lower:
            for genre in ['action', 'adventure', 'rpg', 'roguelike', 'puzzle', 'platformer', 'simulation']:
                if genre in line_lower or (i + 1 < len(lines) and genre in lines[i + 1].lower()):
                    extracted['genre'] = genre
                    break
        
        # Look for inspiration/reference keywords
        if 'inspir' in line_lower or 'reference' in line_lower or 'like' in line_lower:
            # Check next few lines for game names
            for j in range(i, min(i + 3, len(lines))):
                for game in ['Hades', 'Celeste', 'Hollow Knight', 'Dark Souls', 'Zelda', 'Mario']:
                    if game.lower() in lines[j].lower() and game not in extracted['inspirations']:
                        extracted['inspirations'].append(game)
    
    # If no name found, use first significant line
    if not extracted['gameName']:
        for line in lines:
            if line.strip() and not line.startswith('#') and len(line.strip()) > 3:
                extracted['gameName'] = line.strip()[:50]
                break
    
    # Extract concept (first paragraph after title)
    concept_lines = []
    in_concept = False
    for line in lines:
        if line.startswith('# '):
            in_concept = True
            continue
        if in_concept:
            if line.strip():
                concept_lines.append(line.strip())
            if len(concept_lines) >= 3:
                break
    
    if concept_lines:
        extracted['concept'] = ' '.join(concept_lines)[:300]
    
    return {
        "extracted": extracted,
        "confidence": 0.5,  # Low confidence for basic extraction
        "source": "regex"  # Could be "llm" when enhanced
    }

@router.get("/tasks")
async def get_tasks(uproject_path: str):
    """Get tasks from the tasks.json file"""
    docs_path = get_docs_path(uproject_path)
    
    if not docs_path:
        return {"tasks": [], "sectors": []}
    
    tasks_file = docs_path / ".companion" / "tasks.json"
    
    if not tasks_file.exists():
        return {"tasks": [], "sectors": []}
    
    try:
        data = json.loads(tasks_file.read_text())
        return data
    except:
        return {"tasks": [], "sectors": []}

@router.post("/tasks/sync")
async def sync_tasks(
    tasks: List[Dict[str, Any]] = Body(...),
    sectors: List[Dict[str, Any]] = Body(...),
    uproject_path: str = Body(...)
):
    """Sync tasks to the tasks.json file"""
    docs_path = get_docs_path(uproject_path)
    
    if not docs_path:
        raise HTTPException(status_code=400, detail="Invalid uproject path")
    
    config_path = docs_path / ".companion"
    config_path.mkdir(parents=True, exist_ok=True)
    
    tasks_file = config_path / "tasks.json"
    
    data = {
        "sectors": sectors,
        "tasks": tasks,
        "updated_at": datetime.now().isoformat()
    }
    
    tasks_file.write_text(json.dumps(data, indent=2))
    
    return {"success": True}


# ============ DYNAMIC WORKFLOW GENERATION ============

class WorkflowGenerateRequest(BaseModel):
    """Request to generate dynamic workflow content"""
    workflow_id: str
    step_index: int
    step_id: str
    previous_responses: Dict[str, Any] = {}
    locale: str = 'en'
    agent: str = 'game-designer'

class DocumentGenerateRequest(BaseModel):
    """Request to generate a document from workflow responses"""
    workflow_id: str
    responses: Dict[str, Any]
    template: str
    output_path: str
    locale: str = 'en'

class PartyReviewRequest(BaseModel):
    """Request for multi-agent document review"""
    document_content: str
    document_type: str  # 'brief', 'gdd', 'architecture'
    agents: List[str] = ['game-architect', 'game-dev', 'game-designer']
    locale: str = 'en'

# Agent personalities for dynamic content
AGENT_PERSONALITIES = {
    'game-designer': {
        'name': 'Game Designer',
        'tone': 'creative and enthusiastic',
        'focus': 'player experience, fun, engagement',
        'emoji': 'ðŸŽ®'
    },
    'game-architect': {
        'name': 'Game Architect', 
        'tone': 'analytical and structured',
        'focus': 'systems, scalability, technical feasibility',
        'emoji': 'ðŸ—ï¸'
    },
    'game-dev': {
        'name': 'Game Developer',
        'tone': 'practical and solution-oriented',
        'focus': 'implementation, performance, code quality',
        'emoji': 'ðŸ’»'
    },
    'game-qa': {
        'name': 'QA Specialist',
        'tone': 'thorough and detail-oriented',
        'focus': 'testing, edge cases, user experience issues',
        'emoji': 'ðŸ”'
    }
}

@router.post("/workflow/generate")
async def generate_workflow_content(request: WorkflowGenerateRequest):
    """Generate dynamic workflow content using LLM
    
    This endpoint can be enhanced with actual LLM calls.
    For now, returns localized fallback content.
    """
    agent = AGENT_PERSONALITIES.get(request.agent, AGENT_PERSONALITIES['game-designer'])
    
    # Localized messages (fallback)
    messages = {
        'en': {
            'welcome': f"Hi! I'm your {agent['name']}. Let's work on this together!",
            'continue': "Great progress! Let's continue.",
            'almost_done': "We're almost there! Just a few more questions.",
            'genre_prompt': "What genre best describes your game?",
            'concept_prompt': "Tell me about your game concept.",
        },
        'fr': {
            'welcome': f"Salut ! Je suis ton {agent['name']}. Travaillons ensemble !",
            'continue': "Super avancement ! Continuons.",
            'almost_done': "On y est presque ! Encore quelques questions.",
            'genre_prompt': "Quel genre dÃ©crit le mieux ton jeu ?",
            'concept_prompt': "Parle-moi de ton concept de jeu.",
        },
        'es': {
            'welcome': f"Â¡Hola! Soy tu {agent['name']}. Â¡Trabajemos juntos!",
            'continue': "Â¡Gran progreso! Continuemos.",
            'almost_done': "Â¡Ya casi terminamos! Solo algunas preguntas mÃ¡s.",
            'genre_prompt': "Â¿QuÃ© gÃ©nero describe mejor tu juego?",
            'concept_prompt': "CuÃ©ntame sobre el concepto de tu juego.",
        }
    }
    
    locale_messages = messages.get(request.locale, messages['en'])
    
    # Generate contextual message based on step and previous responses
    step_messages = []
    
    if request.step_index == 0:
        step_messages.append(locale_messages['welcome'])
    elif request.step_index >= 3:
        step_messages.append(locale_messages['almost_done'])
    else:
        step_messages.append(locale_messages['continue'])
    
    # Add context-aware message based on previous responses
    if 'genre' in request.previous_responses:
        genre = request.previous_responses['genre']
        if request.locale == 'fr':
            step_messages.append(f"IntÃ©ressant choix : {genre} ! Explorons Ã§a.")
        elif request.locale == 'es':
            step_messages.append(f"Â¡Interesante elecciÃ³n: {genre}! Exploremos esto.")
        else:
            step_messages.append(f"Interesting choice: {genre}! Let's explore that.")
    
    return {
        "agentMessage": ' '.join(step_messages),
        "agentEmoji": agent['emoji'],
        "suggestions": [],
        "source": "fallback"  # Would be "llm" with actual LLM integration
    }

@router.post("/workflow/adapt")
async def adapt_workflow_questions(request: WorkflowGenerateRequest):
    """Adapt workflow questions based on previous responses
    
    Returns suggested modifications to questions based on context.
    """
    adaptations = {}
    
    # Genre-based adaptations
    genre = request.previous_responses.get('genre', '')
    
    if genre == 'roguelike':
        adaptations['mechanics'] = {
            'suggestions': ['Procedural generation', 'Permadeath', 'Meta-progression', 'Run variety'],
            'placeholder': 'e.g., procedural levels, permadeath with unlocks...'
        }
    elif genre == 'rpg':
        adaptations['mechanics'] = {
            'suggestions': ['Skill trees', 'Dialogue choices', 'Equipment system', 'Quest branching'],
            'placeholder': 'e.g., branching dialogue, character builds...'
        }
    elif genre == 'action':
        adaptations['mechanics'] = {
            'suggestions': ['Combo system', 'Dodge/parry', 'Weapon variety', 'Boss battles'],
            'placeholder': 'e.g., fast combat, weapon switching...'
        }
    
    # Platform-based adaptations
    platforms = request.previous_responses.get('platform', [])
    if 'mobile' in platforms:
        adaptations['controls'] = {
            'note': 'Consider touch-friendly controls for mobile',
            'suggestions': ['Simple tap controls', 'Auto-aim assist', 'Short session design']
        }
    
    return {
        "adaptations": adaptations,
        "source": "rules"  # Could be "llm" with actual LLM integration
    }

@router.post("/documents/generate")
async def generate_document(request: DocumentGenerateRequest):
    """Generate a document from workflow responses
    
    Replaces template placeholders with actual responses.
    Can be enhanced with LLM for better formatting.
    """
    content = request.template
    
    # Replace all placeholders
    for key, value in request.responses.items():
        placeholder = "{{" + key + "}}"
        
        if isinstance(value, list):
            formatted_value = '\n'.join(f"- {item}" for item in value)
        else:
            formatted_value = str(value) if value else ''
        
        content = content.replace(placeholder, formatted_value)
    
    # Add generation metadata
    content = content.replace("{{date}}", datetime.now().strftime('%Y-%m-%d'))
    
    # Clean up any remaining empty placeholders
    import re
    content = re.sub(r'\{\{[^}]+\}\}', '', content)
    
    return {
        "content": content,
        "path": request.output_path,
        "source": "template"  # Could be "llm" with actual LLM enhancement
    }

@router.post("/party/review")
async def party_review(request: PartyReviewRequest):
    """Multi-agent document review (Party Mode)
    
    Each agent reviews the document from their perspective.
    """
    reviews = []
    
    # Localized review templates
    review_templates = {
        'game-architect': {
            'en': [
                "From a systems perspective, I see {strength}.",
                "Consider the technical implications of {concern}.",
                "The architecture could benefit from {suggestion}."
            ],
            'fr': [
                "D'un point de vue systÃ¨mes, je vois {strength}.",
                "ConsidÃ¨re les implications techniques de {concern}.",
                "L'architecture pourrait bÃ©nÃ©ficier de {suggestion}."
            ]
        },
        'game-dev': {
            'en': [
                "Implementation-wise, {strength} is solid.",
                "We should prototype {concern} early.",
                "I'd suggest {suggestion} for better performance."
            ],
            'fr': [
                "CÃ´tÃ© implÃ©mentation, {strength} est solide.",
                "On devrait prototyper {concern} rapidement.",
                "Je suggÃ¨re {suggestion} pour de meilleures performances."
            ]
        },
        'game-designer': {
            'en': [
                "The player experience around {strength} feels strong.",
                "I'm curious about how {concern} will feel in-game.",
                "What if we added {suggestion} to enhance engagement?"
            ],
            'fr': [
                "L'expÃ©rience joueur autour de {strength} semble forte.",
                "Je me demande comment {concern} se ressentira en jeu.",
                "Et si on ajoutait {suggestion} pour amÃ©liorer l'engagement ?"
            ]
        }
    }
    
    # Generate reviews for each agent
    for agent_id in request.agents:
        agent = AGENT_PERSONALITIES.get(agent_id, AGENT_PERSONALITIES['game-designer'])
        templates = review_templates.get(agent_id, review_templates['game-designer'])
        locale_templates = templates.get(request.locale, templates['en'])
        
        # Simulate review (would be LLM-generated in production)
        review_points = []
        
        # Analyze document for key terms
        doc_lower = request.document_content.lower()
        
        if 'roguelike' in doc_lower or 'procedural' in doc_lower:
            review_points.append({
                'type': 'strength',
                'text': locale_templates[0].format(strength='procedural generation approach')
            })
        
        if 'multiplayer' in doc_lower or 'online' in doc_lower:
            review_points.append({
                'type': 'concern', 
                'text': locale_templates[1].format(concern='network synchronization')
            })
        
        if len(request.document_content) > 1000:
            review_points.append({
                'type': 'suggestion',
                'text': locale_templates[2].format(suggestion='breaking this into smaller milestones')
            })
        
        # Default review if no specific points
        if not review_points:
            if request.locale == 'fr':
                review_points.append({
                    'type': 'general',
                    'text': f"Le document est bien structurÃ©. Continuons Ã  itÃ©rer !"
                })
            else:
                review_points.append({
                    'type': 'general',
                    'text': f"The document is well structured. Let's keep iterating!"
                })
        
        reviews.append({
            'agent': agent_id,
            'agentName': agent['name'],
            'emoji': agent['emoji'],
            'tone': agent['tone'],
            'points': review_points
        })
    
    return {
        "reviews": reviews,
        "source": "rules"  # Would be "llm" in production
    }
