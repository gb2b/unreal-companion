# P2.0 Refactoring Structurel Web-UI

## Objectif

Documenter et implémenter les modifications structurelles du web-ui existant pour supporter les nouvelles fonctionnalités (contexte hiérarchique, questions interactives, quick interactions, tips, réflexions agents).

> **Principe CRITIQUE :** On garde le code existant qui fonctionne, on ÉTEND, on ne recrée pas !

## Prérequis

- [x] P1.1 - Structure globale (pour comprendre les nouveaux formats)

## Architecture Existante (NE PAS DUPLIQUER)

### Stores Zustand (9 existants)

| Store | Fichier | Rôle |
|-------|---------|------|
| chatStore | `stores/chatStore.ts` | Messages, conversation, tool calls |
| projectStore | `stores/projectStore.ts` | Projets, persistence localStorage |
| **workflowStore** | `stores/workflowStore.ts` | Sessions workflow, WebSocket streaming |
| llmStore | `stores/llmStore.ts` | Config LLM, providers, API keys |
| connectionStore | `stores/connectionStore.ts` | Status Unreal/MCP/LLM |
| logsStore | `stores/logsStore.ts` | Activity logs real-time |
| **studioStore** | `stores/studioStore.ts` | Tasks, sectors, production board |
| themeStore | `stores/themeStore.ts` | Dark/light theme |
| toastStore | `stores/toastStore.ts` | Notifications |

### Services Backend (à étendre, pas recréer)

| Service | Fichier | Rôle |
|---------|---------|------|
| LLM | `services/llm.py` | Multi-provider, streaming, tools |
| Workflow Engine | `services/workflow/engine.py` | Orchestration workflows |
| State Manager | `services/workflow/state_manager.py` | Sessions YAML |
| Prompt Builder | `services/workflow/prompt_builder.py` | Construction prompts |
| **Context Discovery** | `services/context_discovery.py` | Scan projet pour GDD, docs |
| Agent Manager | `services/agent_manager.py` | Définitions agents |

### Routes API (pattern : `server/api/`)

- `/api/chat` — Chat avec tools
- `/api/workflows` — Workflows REST + WebSocket
- `/api/projects` — CRUD projets
- `/api/context` — Context discovery
- `/api/studio` — **Tasks management (existe déjà !)**
- `/api/llm`, `/api/agents`, `/api/status`, etc.

## État Actuel du Web-UI

### Ce qui EXISTE et qu'on GARDE

| Composant | Status | Notes |
|-----------|--------|-------|
| Sessions workflow (SQLite) | ✅ | Persistance, save/load/resume |
| Streaming WebSocket | ✅ | Anthropic + OpenAI |
| Multi-provider LLM | ✅ | Anthropic, OpenAI, Google, Ollama |
| Questions basiques | ✅ | single, multiple, text, textarea, scale |
| Suggestions inline | ✅ | choice, reference, example |
| Quick Actions | ✅ | Continue, Edit, Help, YOLO, Party |
| Context files | ✅ | Upload markdown/images/PDF |
| Zustand stores (9) | ✅ | chat, workflow, project, llm, theme... |
| Shadcn/ui components | ✅ | Base UI library |

## Modifications Backend

### 1. Nouveaux Services à Créer

```
server/services/
├── context_manager.py      # NOUVEAU: Contexte hiérarchique + injection
├── fact_extractor.py       # NOUVEAU: Extraction de facts depuis réponses
├── tips_service.py         # NOUVEAU: Génération tips contextuels
└── workflow/
    └── prompt_builder.py   # MODIFIER: Ajouter injection sélective
```

#### context_manager.py

```python
class ContextManager:
    """Gère le contexte hiérarchique pour les appels LLM."""

    def build_context(
        self,
        project_id: str,
        workflow_id: str,
        step_id: str,
        max_tokens: int = 4000
    ) -> BuiltContext:
        """
        Construit le contexte en 3 niveaux:
        - CORE: toujours inclus (~500 tokens)
        - RELEVANT: selon l'étape (~1000 tokens)
        - DETAILS: si demandé (~variable)
        """
        pass

    def get_facts(self, project_id: str) -> dict[str, Any]:
        """Récupère les facts extraits du projet."""
        pass

    def invalidate_cache(self, project_id: str):
        """Invalide le cache quand le contexte change."""
        pass
```

#### fact_extractor.py

```python
class FactExtractor:
    """Extrait des facts structurés des réponses utilisateur."""

    async def extract_from_response(
        self,
        response: str,
        question_context: dict
    ) -> list[Fact]:
        """
        Utilise un petit modèle (haiku) pour extraire les facts.
        Retourne des données structurées, pas du texte brut.
        """
        pass

    async def extract_from_document(
        self,
        document_path: str,
        document_type: str
    ) -> list[Fact]:
        """Extrait les facts d'un document (GDD, Brief, etc.)."""
        pass
```

#### tips_service.py

```python
class TipsService:
    """Génère et gère les tips contextuels."""

    async def get_tip_for_context(
        self,
        project_id: str,
        workflow_id: str,
        step_id: str,
        category: str = None
    ) -> Tip | None:
        """Retourne un tip pertinent pour le contexte actuel."""
        pass

    async def record_feedback(
        self,
        tip_id: str,
        useful: bool,
        user_id: str
    ):
        """Enregistre le feedback sur un tip."""
        pass
```

### 2. Nouvelles Routes API

```python
# server/api/context.py - ÉTENDRE
@router.get("/hierarchy")
async def get_context_hierarchy(project_id: str):
    """Retourne le contexte sous forme hiérarchique."""
    pass

@router.get("/facts")
async def get_facts(project_id: str):
    """Retourne les facts extraits du projet."""
    pass

@router.post("/facts/extract")
async def extract_facts(project_id: str, source: str):
    """Force l'extraction de facts depuis une source."""
    pass

# server/api/tips.py - NOUVEAU
@router.get("/{question_id}")
async def get_tips_for_question(question_id: str):
    """Retourne les tips pour une question."""
    pass

@router.post("/{tip_id}/feedback")
async def record_tip_feedback(tip_id: str, useful: bool):
    """Enregistre le feedback sur un tip."""
    pass

# server/api/workflows.py - ÉTENDRE
@router.get("/{workflow_id}/interactions")
async def get_available_interactions(workflow_id: str, step_id: str):
    """Retourne les quick interactions disponibles pour une étape."""
    pass
```

### 3. Nouveaux Modèles Database

```python
# server/models/fact.py - NOUVEAU
class Fact(Base):
    __tablename__ = "facts"

    id = Column(String, primary_key=True)
    project_id = Column(String, ForeignKey("projects.id"))

    # Catégorie et clé
    category = Column(String)  # vision, genre, mechanics, etc.
    key = Column(String)       # pitch, primary, core_loop, etc.
    value = Column(Text)       # Valeur extraite

    # Métadonnées
    source_type = Column(String)  # response, document, manual
    source_id = Column(String)    # ID de la source
    confidence = Column(Float)    # 0.0-1.0

    created_at = Column(DateTime)
    updated_at = Column(DateTime)

# server/models/tip.py - NOUVEAU
class Tip(Base):
    __tablename__ = "tips"

    id = Column(String, primary_key=True)

    # Contenu
    content = Column(Text)
    category = Column(String)  # game_design, technical, inspiration, warning

    # Ciblage
    question_type = Column(String, nullable=True)  # Si spécifique à un type
    workflow_id = Column(String, nullable=True)    # Si spécifique à un workflow

    # Tracking
    shown_count = Column(Integer, default=0)
    useful_count = Column(Integer, default=0)
    not_useful_count = Column(Integer, default=0)

# server/models/tip_dismissal.py - NOUVEAU
class TipDismissal(Base):
    __tablename__ = "tip_dismissals"

    id = Column(String, primary_key=True)
    tip_id = Column(String, ForeignKey("tips.id"))
    user_id = Column(String)
    dismissed_at = Column(DateTime)
```

### 4. Modifications au prompt_builder.py

```python
# server/services/workflow/prompt_builder.py - MODIFIER

class PromptBuilder:
    def __init__(self, context_manager: ContextManager):
        self.context_manager = context_manager

    def build_system_prompt(
        self,
        agent: Agent,
        workflow: Workflow,
        step: WorkflowStep,
        project_id: str
    ) -> str:
        """
        Construit le system prompt avec:
        1. Persona de l'agent
        2. Contexte hiérarchique (via context_manager)
        3. Instructions spécifiques à l'étape
        """
        # Récupérer le contexte optimisé
        context = self.context_manager.build_context(
            project_id=project_id,
            workflow_id=workflow.id,
            step_id=step.id,
            max_tokens=step.context_needs.get('max_tokens', 3000)
        )

        # Injecter seulement ce qui est demandé
        facts_needed = step.context_needs.get('facts', [])
        relevant_facts = {
            k: v for k, v in context.facts.items()
            if k in facts_needed
        }

        # Construire le prompt
        return f"""
{agent.system_prompt}

## Contexte Projet
{self._format_facts(relevant_facts)}

## Étape Actuelle
{step.title}

## Instructions
{step.agent_message}
"""
```

## Modifications Frontend

### 1. Nouveaux Composants

```
src/components/
├── input/                          # Types de questions interactifs
│   ├── SpectrumSlider.tsx          # NOUVEAU: Jauge A ↔ B
│   ├── EmojiScale.tsx              # NOUVEAU: Échelle émotionnelle
│   ├── ChoiceCards.tsx             # NOUVEAU: Choix visuel A ou B
│   └── AppreciationGauge.tsx       # NOUVEAU: Feedback par jauge
│
├── quick/                          # Quick interactions
│   ├── SpeedRound.tsx              # NOUVEAU: 5 mots en temps limité
│   ├── ThisOrThat.tsx              # NOUVEAU: Choix binaires rapides
│   ├── WordAssociation.tsx         # NOUVEAU: Associations libres
│   └── WildCard.tsx                # NOUVEAU: Questions créatives
│
├── tips/                           # Système de tips
│   ├── DailyTip.tsx                # NOUVEAU: Affichage tip
│   └── TipFeedback.tsx             # NOUVEAU: Feedback buttons
│
└── workflow/
    ├── AgentThinking.tsx           # NOUVEAU: Réflexions visibles
    ├── LLMExampleCard.tsx          # NOUVEAU: Exemples dynamiques
    └── QuestionRenderer.tsx        # MODIFIER: Supporter nouveaux types
```

### 2. Nouveaux Stores Zustand

```typescript
// src/stores/contextStore.ts - NOUVEAU
interface ContextState {
  facts: Record<string, any>;
  hierarchy: ContextNode[];
  isLoading: boolean;

  // Actions
  loadFacts: (projectId: string) => Promise<void>;
  loadHierarchy: (projectId: string) => Promise<void>;
  invalidateCache: () => void;
}

// src/stores/tipsStore.ts - NOUVEAU
interface TipsState {
  currentTip: Tip | null;
  dismissedTips: string[];

  // Actions
  loadTipForContext: (context: TipContext) => Promise<void>;
  dismissTip: (tipId: string) => void;
  recordFeedback: (tipId: string, useful: boolean) => Promise<void>;
}
```

### 3. Extensions de Types

```typescript
// src/types/workflow.ts - ÉTENDRE

// Nouveaux types de questions
type QuestionType =
  | 'text' | 'textarea' | 'single' | 'multiple' | 'scale'  // existants
  | 'spectrum'          // Jauge entre deux extrêmes
  | 'emotional_scale'   // Échelle d'émojis
  | 'visual_ab'         // Choix A/B avec visuels
  | 'appreciation';     // Jauge de feedback

// Extension pour les questions interactives
interface SpectrumQuestion extends BaseQuestion {
  type: 'spectrum';
  extremes: {
    left: { label: LocalizedString; description?: LocalizedString };
    right: { label: LocalizedString; description?: LocalizedString };
  };
  allow_comment?: boolean;
}

interface EmotionalScaleQuestion extends BaseQuestion {
  type: 'emotional_scale';
  scale: Array<{
    emoji: string;
    label: LocalizedString;
  }>;
}

interface VisualABQuestion extends BaseQuestion {
  type: 'visual_ab';
  option_a: { label: LocalizedString; image?: string; description?: LocalizedString };
  option_b: { label: LocalizedString; image?: string; description?: LocalizedString };
  allow_other?: boolean;
}

// Quick interactions
interface QuickInteraction {
  type: 'speed_round' | 'this_or_that' | 'word_association' | 'wild_card';
  config: {
    word_count?: number;      // Pour speed_round
    timer?: number;           // Secondes (0 = pas de timer)
    questions_count?: number; // Pour this_or_that
  };
}

// Agent thinking
interface AgentThinking {
  phrases: string[];
  contextual: boolean;
  current_phrase?: string;
  interval_ms?: number;  // Défaut: 2500
}
```

### 4. Modifications au QuestionRenderer

```tsx
// src/components/workflow/QuestionRenderer.tsx - MODIFIER

import { SpectrumSlider } from '../input/SpectrumSlider';
import { EmojiScale } from '../input/EmojiScale';
import { ChoiceCards } from '../input/ChoiceCards';
import { AppreciationGauge } from '../input/AppreciationGauge';

export function QuestionRenderer({ question, onAnswer }: Props) {
  switch (question.type) {
    // Types existants
    case 'text':
    case 'textarea':
    case 'single':
    case 'multiple':
    case 'scale':
      return <ExistingQuestionComponent {...} />;

    // Nouveaux types
    case 'spectrum':
      return <SpectrumSlider question={question} onAnswer={onAnswer} />;

    case 'emotional_scale':
      return <EmojiScale question={question} onAnswer={onAnswer} />;

    case 'visual_ab':
      return <ChoiceCards question={question} onAnswer={onAnswer} />;

    case 'appreciation':
      return <AppreciationGauge question={question} onAnswer={onAnswer} />;

    default:
      return <FallbackTextInput {...} />;
  }
}
```

## Migration Strategy

### Étape 1 : Ajouter sans casser

```
1. Créer les nouveaux fichiers (services, composants, stores)
2. Ajouter les nouvelles routes API (sans modifier les existantes)
3. Ajouter les nouveaux modèles DB (migration Alembic)
4. Les anciennes fonctionnalités continuent de marcher
```

### Étape 2 : Intégrer progressivement

```
1. Modifier prompt_builder.py pour utiliser context_manager (optionnel)
2. Modifier QuestionRenderer pour supporter les nouveaux types
3. Ajouter les stores et les connecter
4. Tests de non-régression
```

### Étape 3 : Activer les features

```
1. Activer l'extraction de facts dans les workflows
2. Activer les tips (via config)
3. Activer les réflexions agents (via config)
4. Documentation utilisateur
```

## Critères d'Acceptation

### Backend

- [ ] `context_manager.py` créé et fonctionnel
- [ ] `fact_extractor.py` créé et fonctionnel
- [ ] `tips_service.py` créé et fonctionnel
- [ ] Nouvelles routes API documentées et testées
- [ ] Modèles DB créés avec migrations
- [ ] `prompt_builder.py` modifié pour injection sélective
- [ ] Tests unitaires pour chaque service

### Frontend

- [ ] 4 composants input créés (Spectrum, Emoji, ChoiceCards, Appreciation)
- [ ] 4 composants quick créés (SpeedRound, ThisOrThat, WordAssociation, WildCard)
- [ ] 2 composants tips créés (DailyTip, TipFeedback)
- [ ] AgentThinking.tsx créé
- [ ] LLMExampleCard.tsx créé
- [ ] contextStore et tipsStore créés
- [ ] QuestionRenderer étendu
- [ ] Tests pour chaque composant

### Intégration

- [ ] Anciennes fonctionnalités non cassées
- [ ] Nouveaux types de questions fonctionnels
- [ ] Tips affichés correctement
- [ ] Réflexions agents visibles pendant loading
- [ ] Facts extraits automatiquement

### Onboarding (Améliorations)

- [ ] Étape "Team" ajoutée : présentation de l'équipe virtuelle (Zelda, Solid, Lara...)
- [ ] Étape "Quick Start" ajoutée : lancer workflow ou explorer
- [ ] Welcome amélioré : "Bienvenue dans ton studio virtuel !"
- [ ] Ready amélioré : mention méthodologie BMGD avec lien
- [ ] Tests onboarding mis à jour

## Tests à Écrire

### Backend

```python
# tests/services/test_context_manager.py
def test_build_context_respects_max_tokens():
def test_build_context_includes_core_always():
def test_build_context_filters_by_step_needs():
def test_cache_invalidation():

# tests/services/test_fact_extractor.py
def test_extract_facts_from_response():
def test_extract_facts_from_document():
def test_confidence_scoring():

# tests/services/test_tips_service.py
def test_get_contextual_tip():
def test_tip_not_shown_if_dismissed():
def test_feedback_recording():
```

### Frontend

```typescript
// src/components/input/__tests__/
describe('SpectrumSlider', () => {
  it('renders extremes labels');
  it('returns value 0-100');
  it('allows optional comment');
});

describe('EmojiScale', () => {
  it('renders all emojis');
  it('highlights selection');
  it('calls onChange');
});

// etc.
```

## Notes

- **Compatibilité** : Les workflows existants (TypeScript) continuent de fonctionner
- **Nouveaux workflows** : Peuvent utiliser les nouveaux types de questions
- **Configuration** : Nouvelles features activables via config utilisateur
- **Performance** : Le context_manager utilise du caching pour éviter les recalculs
