# P4.1 Workflows CLI-Ready

## Objectif

Rendre les workflows ex√©cutables en CLI (Claude Code, Cursor) avec parsing YAML, questions s√©quentielles, et g√©n√©ration d'artifacts.

## Pr√©requis

- [x] P2.4 - Workflows YAML d√©finis
- [x] P2.6 - Gestion sessions

## Fichiers √† Cr√©er

- `cli/workflow_runner.py` - Ex√©cuteur de workflows CLI
- `cli/session_manager.py` - Gestion sessions CLI
- Documentation dans `Docs/CLI/`

## Sp√©cifications

### Utilisation CLI

```bash
# Lister les workflows disponibles
companion workflow list

# D√©marrer un workflow
companion workflow start game-brief

# Reprendre une session
companion workflow resume

# Voir le status
companion workflow status
```

### Exemple de Session CLI

```
$ companion workflow start quick-start

üöÄ Quick Start - D√©marrage Rapide
Estim√©: ~2 min

ü§ñ Game Designer:
"Allons √† l'essentiel ! C'est quoi ton jeu ?"

? Nom du projet: The Last Shard

ü§ñ "The Last Shard, j'aime bien ! Et en une phrase ?"

? Pitch en une phrase:
  > Explorer un monde fig√© dans le temps pour d√©couvrir pourquoi

ü§ñ "Myst√©rieux ! Et le genre ?"

? Genre:
  ‚ùØ Action
    RPG
    Puzzle
    Autre...

[Genre s√©lectionn√©: RPG]

ü§ñ "Parfait ! Voici ton brief rapide..."

‚ú® Session termin√©e!
üìÑ Artifact cr√©√©: artifacts/briefs/quick-brief.md

Prochaines √©tapes sugg√©r√©es:
  1. companion workflow start game-brief  # Approfondir
  2. companion workflow start brainstorm  # Explorer les m√©caniques
```

### Workflow Runner

```python
class CLIWorkflowRunner:
    def __init__(self, project_path: str):
        self.project_path = project_path
        self.session_manager = SessionManager(project_path)

    async def run_workflow(self, workflow_id: str):
        """Ex√©cute un workflow de mani√®re interactive en CLI."""

        # Charger le workflow
        workflow = self.load_workflow(workflow_id)

        # V√©rifier s'il y a une session existante
        existing = self.session_manager.find_active(workflow_id)
        if existing:
            if self.prompt_resume(existing):
                return await self.resume_session(existing)

        # Nouvelle session
        session = self.session_manager.create(workflow_id)

        # Header
        self.print_header(workflow)

        # Parcourir les steps
        for step in workflow.steps:
            if not self.should_show_step(step, session.responses):
                continue

            await self.run_step(step, session)

        # G√©n√©rer l'artifact
        artifact = self.generate_artifact(workflow, session)

        # C√©l√©bration finale
        self.print_completion(workflow, artifact)

        return session

    async def run_step(self, step: WorkflowStep, session: Session):
        """Ex√©cute une √©tape du workflow."""

        # Message de l'agent
        agent_message = await self.generate_agent_message(step, session)
        self.print_agent_message(agent_message)

        # Questions de l'√©tape
        for question in step.questions:
            if not self.should_show_question(question, session.responses):
                continue

            answer = await self.prompt_question(question, session)

            # R√©action de l'agent
            reaction = await self.generate_reaction(answer, session)
            self.print_reaction(reaction)

            # Sauvegarder
            session.add_response(step.id, question.id, answer, reaction)
            self.session_manager.save(session)

        # Milestone?
        if step.milestone:
            self.print_milestone(step.milestone, session)
```

### Types de Questions CLI

```python
def prompt_question(self, question: WorkflowQuestion, session: Session) -> str:
    """Affiche une question et r√©cup√®re la r√©ponse."""

    if question.type == 'text':
        return inquirer.text(
            message=question.prompt,
            default=question.placeholder
        ).execute()

    elif question.type == 'textarea':
        # Multi-ligne avec √©diteur
        return inquirer.text(
            message=question.prompt,
            multiline=True
        ).execute()

    elif question.type == 'single':
        choices = [opt.label for opt in question.options]
        if question.allow_custom:
            choices.append("Autre...")

        answer = inquirer.select(
            message=question.prompt,
            choices=choices
        ).execute()

        if answer == "Autre...":
            return inquirer.text(message="Pr√©cise:").execute()
        return answer

    elif question.type == 'multiple':
        choices = [opt.label for opt in question.options]
        return inquirer.checkbox(
            message=question.prompt,
            choices=choices,
            min_selections=question.min_selections or 1
        ).execute()
```

### G√©n√©ration Artifact

```python
def generate_artifact(self, workflow: Workflow, session: Session) -> Path:
    """G√©n√®re l'artifact final depuis le template."""

    template = workflow.output.template
    variables = self.collect_variables(session)

    # Remplacer les variables
    content = self.render_template(template, variables)

    # Chemin de sortie
    output_path = self.companion_path / workflow.output.path
    output_path.parent.mkdir(parents=True, exist_ok=True)

    # √âcrire
    output_path.write_text(content)

    # Mettre √† jour l'index
    self.update_artifacts_index(output_path, workflow, session)

    return output_path
```

### Int√©gration avec Claude Code / Cursor

```markdown
# Dans CLAUDE.md du projet

## Workflows Disponibles

Pour conceptualiser ton jeu, utilise les workflows:

```bash
# D√©marrer un brief rapide
companion workflow start quick-start

# Brief complet
companion workflow start game-brief

# Brainstorming
companion workflow start brainstorm
```

Les artifacts g√©n√©r√©s seront dans `.unreal-companion/artifacts/`.
```

## Crit√®res d'Acceptation

- [ ] Commande `companion workflow list` fonctionnelle
- [ ] Commande `companion workflow start <id>` fonctionnelle
- [ ] Questions interactives (text, select, checkbox)
- [ ] R√©actions de l'agent g√©n√©r√©es
- [ ] Sauvegarde session apr√®s chaque r√©ponse
- [ ] Reprise de session possible
- [ ] Artifact g√©n√©r√© √† la fin
- [ ] C√©l√©brations et milestones affich√©s
- [ ] Compatible avec Claude Code / Cursor
- [ ] Tests passent

## Tests √† √âcrire

### Unit Tests

```python
def test_workflow_loading():
    # V√©rifie le chargement YAML

def test_question_prompting():
    # V√©rifie chaque type de question

def test_session_save_resume():
    # V√©rifie sauvegarde et reprise

def test_artifact_generation():
    # V√©rifie la g√©n√©ration du fichier final
```

### Integration Tests

```python
def test_full_workflow_cli():
    # Simule un workflow complet avec inputs
```

## Notes

- Utiliser `inquirer` ou `questionary` pour les prompts interactifs
- Les r√©actions peuvent √™tre g√©n√©r√©es via LLM ou pr√©-d√©finies
- Pr√©voir un mode `--non-interactive` pour les scripts
- Le CLI doit fonctionner sans serveur web (standalone)
